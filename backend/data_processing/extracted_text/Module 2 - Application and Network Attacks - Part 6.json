{
  "filename": "Module 2 - Application and Network Attacks - Part 6.pptx",
  "text": "CEN 3078 Computer Security\nModule 2 – Application and Network Attacks\n\n\n2\nModule 2\nTCP fundamental\nAttacks on the TCP protocol\nDenial-of-Service attack\nSQL injection attack\nCross-side scripting attack\nMiscellaneous: Heartbleed bug and attack, Ransomware, Cryptojacking \nThe Heartbleed Bug and Attack\n3\nVulnerability in the OpenSSL library, specifically the Heartbeat protocol in TLS (Transport Layer Security)\nOpenSSL (widely used library for TLS) drives HTTPS that your web browser relies on for online banking, and other secure transactions\nLaunched in 2012 on web servers built on top of OpenSSL\nDisclosed in 2014\nBackground: the Heartbeat Protocol\n4\nTLS/SSL protocols provide a secure channel between two communicating applications\nHeartbeat extension: implement keep-alive feature of TLS\nMaintains secure session without interruption (e.g., from firewall) when client and server are not sending data to each other for a period of time \nHard to initiate and re-establish secure sessions\nSend request packet to receiver and obtain an acknowledgement packet by doing a copy of the payload content based on payload length L\nThe copy caused the vulnerability; attacker can specify larger L\nHeartbleed bug is an implementation flaw in TLS/SSL heartbeat extension\nHow Response Packet is Constructed\n5\nProblem: how much is copied depends on the value contained in the payload length field\n\nWhat if this value is larger than the actual payload size? \n\nAttack Launch\n6\nAttack Results: Some data from the server’s memory also got copied into the response packet, which will be sent out\nAttack Launch\n7\nTo launch a Heartbleed attack, an attacked sends a specially crafted Heartbeat request packet to the victim\nInside this packet, the number put in the payload size field is larger than the actual payload size\nWhen the packet arrives on receiver side, memcpy() will copy more data into the response packet than the request packet (i.e., receiver does a memory dump)\nThe affected memory may store sensitive information, such as passwords, credit card info or other user information\nThis data will be copied into the response packet and sent to the attacker\nBy sending a heartbeat request to a vulnerable remote server, attackers can dump the server’s memory and steal sensitive information\n0x0016 (22 bytes) is placed in the length field, which exactly matches with the actual length of the payload\nWe play with this length field to perform our attack in the next slide\n\n\nLaunch the Heartbleed Attack\n8\nFrom the code snippet we can see that:\nTLS record’s size = 0x0029 (not including the record header), which is the size of the payload in the TLS record\nThe payload contains a Heartbeat request packet, and has its own header (3 bytes) payload (22 bytes) and paddings (16 bytes)\nThe value 0x0016 is the value that exactly matches with the actual payload (22 bytes), so we will not be able to get any additional data from the server\nWe got some secret from the server\n\nLaunch the Heartbleed Attack\n9\nWe increase this value to higher values (e.g. 0x4000 i.e., 16K; much larger than the actual payload size -> 22 bytes) and start getting larger packets back\nThe attack.py program prints out the payload data in the response packet\nIf no user has logged into the server yet before the attack, there will not be much useful data stored in memory\nWhen running the attack multiple times, we may get back different data, because each request packet might be stored at a different memory address\nSimply update your system’s OpenSSL library. The following two commands can be used for it:\n\n\n\nThe following code shows how the OpenSSL library is fixed\n\nFixing the Heartbleed Bug\n10\nFixing the Heartbleed Bug – Use Bounds Checking\n11\nComparing the shown code with the vulnerable version shown earlier, \nAn if statement is added\ns  s3  rrec.length is the total number of bytes in the request packet; this is the actual length and not the one declared in the request packet\nConstant 1  size of type field\nConstant 2  size of length field\nConstant 16  minimum padding length\n\nThe if statement compares whether the declared payload length plus a constant (19) is larger than the actual size of the request packet\nIf larger, the packet is discarded and there will be no reply\nIf attacker send a request packet with larger declared length value, the packet won’t have any effect\nStory: Bounds Checking and Game Design \nCryptojacking\n12\nCryptojacking is the unauthorized use (i.e., hijacking) of someone else’s computer processing power to mine cryptocurrency\n\nHackers do this by either:\nSocial Engineering / Malware: Getting the victim to click on a malicious link (phishing) in an email that loads cryptomining code (malware) on the computer, or \nBrowser-based Attacks: By infecting a website or online ad with JavaScript code that auto-executes once loaded in the victim’s browser (mining will take place as long as browser/tab is open)\n\nEither way, the cryptomining code then works in the background as unsuspecting victims use their computers normally \nSymptoms: overheating of device, high processor usage, slower performance or lags in execution\nHow Cryptojacking Works\n13\nHackers inject a cryptomining script on a website or in an Ad that is placed on multiple sites\nWhen the victim visits the infected website, or if the malicious Ad pops up in the victim’s browser, the script automatically executes\nNo code is stored on the victim’s computer and no damage is done to computers or victims’ data\n\nInteraction with mining pool\nPrevention of Cryptojacking\n14\nUse VPN to encrypt internet connections and hide IP address\nAwareness and Training to thwart social engineering scams\nInstall an Ad-blocking or anti-cryptomining extension on web browsers\nUse end-point protection that is capable of detecting known crypto miners\nKeep your web filtering tools up to date\nMaintain browser extensions\nUse a mobile device management (MDM) solution to better control what’s on users’ devices\n\nDNS and Attacks\n15\nDNS Hierarchy, Zones, and Servers\n\nDNS Query Process\n\nDNS Attacks: Overview\n\nLocal DNS Cache Poisoning Attack\n\nDefense against DNS spoofing attacks\n\n\n\n\n\n\n\n\n\nDNS Domain Hierarchy\n16\nBelow ROOT, we have Top-Level Domain (TLD). Ex: In www.example.com, the TLD is .com\nThe next level of domain hierarchy is second-level domain which are usually assigned to specific entities such as companies, schools etc.\n\n\nDomain (nameserver) namespace is organized in a hierarchical tree-like structure\nEach node is called a domain, or subdomain.\nThe root of the domain is called ROOT, denoted as ‘ . ‘\n\nInternet Assigned Name Authority (IANA) \nDomain Name System (DNS) is a phonebook of the Internet – enables mapping of domain names to IP addresses of machines \nDNS Zone\n17\nHierarchy tree structure depicts subdomains within example.com domain\nIn this case, there are multiple DNS zones one for each country; the zone keeps records of who the management authority is for each of its subdomains\nFor scalability, you have sub-domains on different name servers\n\nDNS is organized according to zones \n\nA zone groups contiguous domains and subdomains on the domain tree and assign management authority to an entity\nusa.example.com is a domain with subdomains as boston, nyc and chicago; Two zones are created for usa.example.com - First contains usa domain, chicago and boston subdomain and second contains nyc subdomain\nZone vs Domain\n18\nA DNS zone only contains a portion of the DNS data for a domain\nIf a domain is not divided into subdomains, the zone and domain are essentially the same, because the zone contains all the DNS data for the domain\nWhen a domain is big, it is divided into subdomains\nTheir DNS data can still be put in the same zone, so domain and zone are still the same\nBut subdomains can have their own zones\n\nAuthoritative Name Servers\n19\nEach DNS zone has at least one authoritative nameserver that publishes information about the zone\n\nIt provides the original and definitive answers to DNS queries\n\nAn authoritative name server can be a master server (primary) or slave server (secondary)\n\nA master server stores the master copies of all zone records whereas a slave server uses an automatic updating mechanism to maintain an identical copy of the master records\n\n\nDNS ROOT Servers\n20\nThe root zone is called ROOT\n\nThere are 13 authoritative nameservers (DNS root servers) for this zone\n\nThey provide the nameserver information about all top-level domains (TLDs)\n\nhttps://www.internic.net/domain/root.zone\n\nThey are the starting point of DNS queries\n\n13 DNS Root Servers\n21\nThey are the most critical infrastructure on the Internet (they mirror the information by having multiple computers at different places in the world – accessible via anycast) \n\n\nIf you can bring down Root servers, the Internet will be down!\nTop Level Domain (TLD)\n22\nInfrastructure TLD:  .arpa\n\nGeneric TLD (gTLD): .com, .net, \n\nSponsored TLD (sTLD): These domains are proposed and sponsored by private agencies or organizations that establish and enforce rules restricting the eligibility to use the TLD:  .edu, .gov, .mil, .travel, .jobs\n\nCountry Code TLD (ccTLD): .au (Australia), .cn (China), .fr (France)\n\nReserved TLD: .example, .test, .localhost, .invalid\n\n\nDNS Query Process\n23\nDNS Cache\nLocal DNS Files\nRecursive\n.com\nLocal DNS Files\n24\n/etc/host: stores IP addresses for some hostnames. Before machine contacts the local DNS servers, it first looks into this file for the IP address.\n\n\n\n\n/etc/resolv.conf: provide information to the machine’s DNS resolver about the IP address of the local DNS server. The IP address of the local DNS server provided by DHCP is also stored here.\nLocal DNS Server and Iterative Query Process\nThe iterative process starts from the ROOT Server\n\nIf it doesn’t know the IP address, it sends back the IP address of the nameservers of the next level server (.NET server) and then the last level server (example.net) which provides the answer\n25\nEmulating Local DNS Server \u000b(Step 1: Ask ROOT)\nDirectly send the query to one of the 13 root servers\n\nNo answer (the root does not know the answer)\n\nGo ask them!\n\n\n26\nSteps 2-3: Ask .net & example.net servers\nAsk a .net nameservers. \nAsk an example.net nameservers. \nGo ask them!\n\n\nFinally got the answer\n\n27\nDNS cache\nWhen the local DNS server gets information from other DNS servers, it caches the information\n\nEach piece of information in the cache has a time-to-live value, so it will be eventually time out and removed from the cache\n28\nQuestion: How local DNS server get’s root server IP? \nAnswer: The Zone file\nDNS Attacks\nDenial-of-Service Attacks (DoS): When the local DNS servers and the authoritative nameservers do not respond to the DNS queries, the machines cannot retrieve IP addresses which essentially cuts down the communication\n\nDNS Spoofing Attacks: \nPrimary goal: provide a fraudulent IP address to victims, tricking them to communicate with a machine that is different from their intention \nExample: If a user’s intention is to visit a bank’s web site to do online banking, but the IP address obtained through the DNS process is attacker’s machine, the user machine will communicate to the attacker’s web server\n29\nOverview of the Attack Surfaces\n30\nDNS queries involve several packets and thus present a broad attack surface in terms of spoofing (1 – 4 in figure below)\n/etc/hosts file\nwith localhost information\n\nYou can also launch DoS attack at all points – root, local DNS server, TLD server\nDNS Attacks on Compromised Machines\nIf attackers have gained the root privileges on a machine, \nModify /etc/resolv.conf: use malicious DNS server as the machine’s local DNS server and can control the entire DNS process\nModify /etc/hosts: add new records to the file, providing the IP addresses for some selected domains\nFor example, attackers can modify IP address of www.bank32.com which can lead to attacker’s machine\n\n31\nSpoofing DNS Replies (from LAN)\n32\nAttacks on user machines : When the user machine sends out a DNS query to its local DNS server, attacker can immediately send a spoofed reply, using local DNS as its source IP address; Attackers can put any arbitrary IP address in the reply\n\nAttacks on local DNS server : Cache Poisoning attack : When the local DNS server sends out iterative queries to get an answer from the DNS servers on the Internet, attackers can send out spoofed replies to the local DNS server; They get accepted as long as they arrive before the actual replies - This is called DNS cache poisoning\n\nAttacks on Nameservers \u000bof a Particular Domain\nUltraDNS: DNS provider for many major e-commerce companies such as Amazon, Walmart, Expedia\n\nIn 2004, DoS against this UltraDNS provider was launched which suffered an outage for an hour\n33\nAttacks on Nameservers \u000bof a Particular Domain\nDNSPod: In 2009, several DNS servers of a Chinese domain service provider were hit by DDoS\nThe attack was meant to target one particular company (Baofeng.com) which is widely popular video streaming site in China\n\nOn the next day of attack, when DNS responses previously cached by the other servers timed out, Baofeng’s media player on users’ machines could not find the IP addresses of the servers because of the attack\n\nDue to the bug in the media player software, instead of waiting, they continuously sent out DNS queries at a faster rate\n\nDue to massive number of DNS queries, they flooded and congested the network of China Telecom (ISP); It impacted 20 provinces and is described as the worst Internet incident in China\n34\nAttacks on Nameservers of \u000ba Particular Domain\nDyn network: In 2016, multiple DDoS attacks were launched against a major DNS service provider for companies like CNN, BBC, HBO, PayPal etc. The attacks are believed to have been launched through botnet consisting of different IoT devices like IP cameras, baby monitors etc. It caused major Internet services unavailable\n35\n"
}