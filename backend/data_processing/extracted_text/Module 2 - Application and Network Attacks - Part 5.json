{
  "filename": "Module 2 - Application and Network Attacks - Part 5.pptx",
  "text": "CEN 3078 Computer Security\nModule 2 – Application and Network Attacks\n\n\n2\nModule 2\nTCP fundamental\nAttacks on the TCP protocol\nDenial-of-Service attack\nSQL injection attack\nCross-side scripting attack\nMiscellaneous: Heartbleed bug and attack, Ransomware, Cryptojacking \nThe Cross-Site Scripting Attack\nIn XSS, an attacker injects malicious code to the victim’s browser via the target website\nWhen code comes from a website, it is considered as trusted with respect to the website, so it can access and change the content on the pages, read cookies belonging to the website and sending out requests on behalf of the user\n\nBasically, code can do whatever the user can do inside the session\nTypes: \nNon-persistent (Reflected) XSS Attack\nPersistent (Stored) XSS Attack\n\n\n3\nSamy Computer Worm\nSamy is a cross-site scripting worm that was designed to propagate across the social networking site MySpace by Samy Kamkar\n\nWithin just 20 hours of its October 4, 2005 release, over one million users had run the payload making Samy the fastest-spreading virus of all time\n4\nClinton-Obama Campaigns XSS Attack\nFinnish security researcher Harry Sintonen published an example of a cross-site scripting vulnerability on votehillary.org\nSintonen's example submits a POST request to the Vote Hillary website and injects an iframe, causing the site to display the contents of Barack Obama's website\n5\nBBC XSS Attack\nA cyber-attack on Twitter platform Tweetdeck infiltrated several accounts, and re-tweeted garbled code\nThe BBC's main Twitter account fell foul of the attack, re-tweeting incomprehensible code\n6\nNon-persistent (Reflected) XSS Attack\nMany websites take input from the user, conduct some activities and then send response to the user in a web page, with the original user input included on the response (i.e., the user input is reflected back)\nE.g., Google search will give back your input and results\nIf a website with a reflective behaviour takes user inputs, then:\nAttackers can put JavaScript code in the input, so when the input is reflected back, the JavaScript code will be injected into the web page from the website\n7\nNon-persistent (Reflected) XSS Attack\nAssume a vulnerable service on website : http://www.example.com/search?input=word, where word is provided by the users\n\nNow the attacker sends the following URL to the victim and tricks him to click the link: http://www.example.com/search?input=<script>alert(“attack”);</script>\n\nOnce the victim clicks on this link, an HTTP GET request will be sent to the www.example.com web server, which returns a page containing the search result, with the original input in the page\nThe input here is a JavaScript code which runs and gives a pop-up message on the victim’s browser\n8\nPersistent (Stored) XSS Attack\nAttackers directly send their data to a target website/server which stores the data in a persistent storage\nIf the website later sends the stored data to other users, it creates a channel between the users and the attackers\n\nExample: User profile in a social network is a channel as it is set by one user and viewed by another\n9\nPersistent (Stored) XSS Attack\nThese channels are supposed to be data channels\nBut data provided by users can contain HTML markups and JavaScript code\nIf the input is not sanitized properly by the website, it is sent to other users’ browsers through the channel and gets executed by the browsers\nBrowsers consider it like any other code coming from the website; Therefore, the code is given the same privileges as that from the website\n10\nDamage Caused by XSS\nWeb defacing: JavaScript code can use DOM (Document Object Model) APIs to access the DOM nodes inside the hosting page; Therefore, the injected JavaScript code can make arbitrary changes to the page\nExample: JavaScript code can change a news article page to something fake or change some pictures on the page\n\n11\nDamage Caused by XSS\n\nSpoofing requests: The injected JavaScript code can send HTTP requests to the server on behalf of the user\n\nStealing information: The injected JavaScript code can also steal victim’s private data including the session cookies, personal data displayed on the web page, data stored locally by the web application\n12\nSelf-Propagation XSS Worm\n13\nWhen an infected profile is viewed by others, the code can further spread – victim is turned into an attacker via a link approach or DOM approach\n\nTo become a real worm, the malicious JavaScript program should be able to propagate itself, i.e. self-propagating cross-site scripting worm\nCountermeasures: The Filter Approach\nRemoves code from user inputs (corrects the mistake of mixing code and data together)\nIt is difficult to implement as there are many ways to embed code other than <script> tag\nUse of open-source libraries that can filter out JavaScript code \nExample: jsoup\n\n14\nCountermeasures: The Encoding Approach\nReplaces HTML markups with alternate representations\nIf data containing JavaScript code is encoded before being sent to the browsers, the embedded JavaScript code will be displayed by browsers, not executed by them\nConverts <script> alert(‘XSS’) </script> to &lt;script&gt;alert(‘XSS’)\n15\nCountermeasures: Using CSP\nHow websites tell browsers which code source is trustworthy is achieved using a security mechanism called Content Security Policy (CSP)\nThis mechanism is specifically designed to defeat XSS and ClickJacking attacks\nCSP has become a standard, which is supported by most browsers nowadays\nCSP not only restricts JavaScript code, it also restricts:\nother page contents, such as limiting where pictures, audio, and video can come from\nwhether a page can be put inside an iframe or not (used for defeating ClickJacking attacks)\n16\nIn-Class Practices\nQuestion 1: In order to implement the classic DoS flood attack, the attacker must generate a sufficiently large volume of packets to exceed the capacity of the link to the target organization. Consider an attack using ICMP echo request (ping) packets that are 500 bytes in size (ignoring framing overhead). How many of these packets per second must the attacker send to flood a target organization using a 0.5-Mbps link? How many per second if the attacker uses a 2-Mbps link? Or a10-Mbps link?\n\nAnswers to Q1\nLet’s have the following parameters: w the bandwidth of the communications channel, and p the minimum number of 500-byte size packets needed to exceed the capacity of the channel. To reach the capacity of the channel (p * 500 * 8) = w, with w expressed in bits, so p = w/4000. Based on it for each case we have:\nw = 0.5 Mbps = 500,000 bits; p = 500000/4000 = 125 packets/second \nw = 2.0 Mbps = 2,000,000 bits; p = 2000000/4000 = 500 packets/second\nw = 10.0 Mbps = 10,000,000 bits; p = 10000000/4000 = 2,500 packets/second\n\nIn-Class Practice\nQuestion 2: Consider a distributed variant of the attack we explore in Problem Q1. Assume the attacker has compromised a number of broadband-connected residential PCs to use as zombie systems. Also assume each such system has an average uplink capacity of 128 kbps. What is the maximum number of 500-byte ICMP echo request (ping) packets a single zombie PC can send per second? How many such zombie systems would the attacker need to flood a target organization using a 0.5-Mbps link? A 2-Mbps link? Or a10-Mbps link? Given reports of botnets composed of many thousands of zombie systems, what can you conclude about their controller’s ability to launch DDoS attacks on multiple such organizations simultaneously? Or on a major organization with multiple, much larger network links than we have considered in these problems?\n\nAnswers to Q2\nLet’s have the following parameters: w the bandwidth of the communications channel, and p the minimum number of 500-byte size packets needed to exceed the capacity of the channel, and z the number of zombies needed to exceed the capacity of the channel. The maximum number of packets a zombie can send is pz = 128,000/4000 =32 pps (packets per second). Based on the results from Q2, the number of required zombies will be z = p/pz = p/32, and for each case we have:\nw = 0.5 Mbps;\t    z = 125pps/32pps = 3,9 (requires 4 zombies)\nw = 2.0 Mbps;     z = 500pps/32pps = 15,6 (requires 16 zombies)\nw = 10.0 Mbps;   z = 2500pps/32pps = 78,1 (requires 79 zombies)\nBased on the results we got above, it suggests that just a few zombies with relatively low capacity communication channel will be able to cause problems to organizations. In the examples above, with corporate bandwidth from 0.5Mbps to 10Mbps, we have a very narrow channel for today’s standards, however the number of zombies required to shut those networks down is small compared with the thousands of zombies that a botnet controller could use. With thousands of zombies conducting flooding DoS attacks, a botnet controller will be able to attack many organizations at the same time or a big organization with multiple links. If the botnet controller manages to increase the size of the packet the attack will be even more effective. \nIn-Class Practices\nQuestion 3: All the information that a server needs to know about a connection is not only contained in the SYN packet, but also in the final ACK packet from the client. Therefore, information-wise, there is no need to allocate a buffer to save the information about half-open connections. If we get rid of this buffer, the SYN flooding attack will not be effective any more. Do you agree with such a statement or not. Please justify your answer.\n\nAnswers to Q3\nBasically, if we get rid of the buffer, we have solved the SYN flooding attack problem, but we will introduce a new and more powerful attack. The attacker can simply send ACK flooding packets, each one causing the server to allocate memory for a full connection, which takes more memory than that for half-open connections.\n\n"
}