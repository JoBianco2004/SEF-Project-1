{
  "filename": "Module 2 - Application and Network Attacks - Part 1.pptx",
  "text": "CEN 3078 Computer Security\nModule 2 – Application and Network Attacks\n\n\n2\nModule 2\nTCP fundamental\nAttacks on the TCP protocol\nDenial-of-Service attack\nSQL injection attack\nCross-side scripting attack\nMiscellaneous: Heartbleed bug and attack, Ransomware, Cryptojacking \n3\nModule 2\nTCP fundamental\nAttacks on the TCP protocol\nDenial-of-Service attack\nSQL injection attack\nCross-side scripting attack\nMiscellaneous: Heartbleed bug and attack, Ransomware, Cryptojacking \nTCP Protocol\n4\nTransmission Control Protocol (TCP) is a core protocol of the Internet protocol suite\nSits on the top of the IP layer; transport layer\nProvide host-to-host communication services for applications\nTwo transport Layer protocols\nTCP: provides a reliable and ordered communication channel between applications\nUDP: lightweight protocol with lower overhead and can be used for applications that do not require reliability or communication order \nTCP Client Program \n5\nTCP Server Program\nStep 1 : Create a socket. Same as Client Program.\n\nStep 2 : Bind to a port number. An application that communicates with others over the network needs to register a port number on its host computer. When the packet arrives, the operating system knows which application is the receiver based on the port number. The server needs to tell the OS which port it is using. This is done via the bind() system call\n6\nTCP Server Program\nStep 3 : Listen for connections. \nAfter the socket is  set up, TCP programs call listen() to wait for connections\nIt tells the system that it is ready to receive connection requests. \nOnce a connection request is received, the operating system will go through the 3-way handshake to establish the connection \nThe established connection is placed in the queue, waiting for the application to take it. The second argument gives the number of connection that can be stored in the queue\n\n7\nTCP Server Program\nStep 4 : Accept a connection request\nAfter the connection is established, an application needs to “accept” the connection before being able to access it. The accept() system call extracts the first connection request from the queue, creates a new socket, and returns the file descriptor referring to the socket\n\nStep 5 : Send and Receive data\nOnce a connection is established and accepted, both sides can send and receive data using this new socket\n\n\n\n8\nTCP Server Program\nfork() system call creates a new process by duplicating the calling process \nOn success, the process ID of the child process is returned in the parent process and 0 in the child process\nLine ① and Line ② executes child and parent process respectively\nTo accept multiple connections :\n9\nWhile loop is a connection queue – waits if there are no connections, and then if they arrive, they are processed one by one\nData Transmission\nOnce a connection is established, OS allocates two buffers at each end, one for sending data (send buffer) and receiving buffer (receive buffer)\n\nWhen an application needs to send data out, it places data into the TCP send buffer\n\n10\nTiming of ~200ms is used to fill the send buffer – max size of a packet you can send to Layer 2\nData Transmission\nEach octet in the send buffer has a sequence number field in the header which indicates the sequence of the packets\nAt the receiver end, these sequence numbers are used to place data in the right position inside receive buffer\n\nOnce data is placed in the receive buffer, they are merged into a single data stream\n\nApplications read from the receive buffer - If no data is available, it typically gets blocked; It gets unblocked when there is enough data to read\n\nThe receiver informs the sender about receiving of data using acknowledgement packets\n\n11\nTCP Header\nTCP Segment: TCP Header + Data. \n\nSource and Destination port (16 bits each): Specify port numbers of the sender and the receiver.\n\nSequence number (32 bits) : Specifies the sequence number of the first octet in the TCP segment. If SYN bit is set, it is the initial sequence number.\nAcknowledgement number (32 bits): Contains the value of the next sequence number expected by the sender of this segment. Valid only if ACK bit is set.\n12\nTCP Header\nHeader length (4 bits): Length of TCP header is measured by the number of 32-bit words in the header, so we multiply by 4 to get number of octets in the header.\nReserved (6 bits): This field is not used.\nCode bits (6 bits): There are six code bits, including SYN,FIN,ACK,RST,PSH and URG.\nWindow (16 bits): Window advertisement to specify the number of octets that the sender of this TCP segment is willing to accept. The purpose of this field is for flow control.\nChecksum (16 bits): The checksum is calculated using part of IP header, TCP header and TCP data.\nUrgent Pointer (16 bits): If the URG code bit is set, the first part of the data contains urgent data (do not consume sequence numbers). The urgent pointer specifies where the urgent data ends and the normal TCP data starts. Urgent data is for priority purposes as they do not wait in line in the receive buffer, and will be delivered to the applications immediately.\nOptions (0-320 bits, divisible by 32): TCP segments can carry a variable length of options which provide a way to deal with the limitations of the original header.\n13\n14\nAt the heart of TCP is the sliding window algorithm, but it needs to address:\nConnections from many different hosts with - different RTT, different capacity at destination, long delays in network that affects order, different network capacity (i.e., congestion) \nFlow control: keep sender from overrunning receiver\nCongestion control: keep sender from overrunning network\nMaintaining Order & Reliability\n15\nFlow and Congestion Control\nBased on flow condition, Window size is changed\nSender capacity (buffer limitation) or Network congestion (packet drop)\n\nSliding window + flow control\nSequenceNum, Acknowledgment, AdvertisedWindow\nSequenceNum: sequence # of the first byte\nReceiver sends AdvertisedWindow based on available capacity\n\nWindow size is less than or equal to the minimum of AdvertisedWindow and CongestionWindow\n\nTCP 3-way Handshake Protocol\nSYN Packet: \nThe client sends a special packet called SYN packet to the server using a randomly generated number x as its sequence number\n\nSYN-ACK Packet:\nOn receiving it, the server sends a reply packet using its own randomly generated number y as its sequence number\n\nACK Packet\nClient sends out ACK packet to conclude the handshake\n16\nKernel establishes send and receive buffer on both sides\nTCP 3-way Handshake Protocol\nWhen the server receives the initial SYN packet, it uses TCB (Transmission Control Block) to store the information about the connection\nThis is called half-open connection as only client-server connection is confirmed\nThe server stores the TCB in a queue that is only for the half-open connection\nAfter the server gets ACK packet, it will take this TCB out of the queue and store in a different place\nIf ACK doesn’t arrive, the server will resend SYN+ACK packet; The TCB will eventually be discarded after a certain time period\n17\n"
}